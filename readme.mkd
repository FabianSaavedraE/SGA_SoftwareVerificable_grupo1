# DiseÃ±o de Software Verificable - Sistema de GestiÃ³n AcadÃ©mica (SGA)

Este proyecto es una implementaciÃ³n de un Sistema de GestiÃ³n AcadÃ©mica (SGA), desarrollado como parte del curso "DiseÃ±o de Software Verificable". El sistema tiene como objetivo principal gestionar cursos, profesores, alumnos, evaluaciones y sus relaciones. Utiliza Python 3.9+, Flask como framework web y MySQL como base de datos.

La arquitectura estÃ¡ diseÃ±ada para ser mantenible y escalable, utilizando patrones como aplicaciÃ³n modular, SQLAlchemy para ORM y migraciones controladas con Flask-Migrate.

---

## Contenidos

- [DiseÃ±o de Software Verificable - Sistema de GestiÃ³n AcadÃ©mica (SGA)](#diseÃ±o-de-software-verificable---sistema-de-gestiÃ³n-acadÃ©mica-sga)
  - [Contenidos](#contenidos)
  - [ğŸ“Œ Instrucciones de uso](#-instrucciones-de-uso)
  - [ğŸ§© ExplicaciÃ³n de la base de datos usada](#-explicaciÃ³n-de-la-base-de-datos-usada)
  - [ğŸ“š Explicaciones de los puntos del enunciado](#-explicaciones-de-los-puntos-del-enunciado)
    - [ğŸ“ CRUD de Cursos](#-crud-de-cursos)
    - [ğŸ‘¨â€ğŸ“ CRUD de Estudiantes](#-crud-de-estudiantes)
    - [ğŸ‘©â€ğŸ« CRUD de Profesores](#-crud-de-profesores)
    - [ğŸ“„ CRUD de Evaluaciones](#-crud-de-evaluaciones)
    - [ğŸ”— Relaciones entre Entidades](#-relaciones-entre-entidades)
  - [âœ¨ Quality of Life tools](#-quality-of-life-tools)
    - [Archivo `query.py`](#archivo-querypy)
  - [Cambios por Vicente Acevedo](#cambios-por-vicente-acevedo)

---

## ğŸ“Œ Instrucciones de uso

1. Clonar el repositorio:

        git clone #PONER EL LINK ACÃ

2. Definir un archivo .env con la variable de base de datos:

        DATABASE_URI=sqlite:///dev.db #Usamos SQLITe por lo que este es el que estÃ¡ predefinido

3. Inicializar la base de datos en consola

        flask db init

4. <a name="migrate_database"></a> Actualizar la base de datos en consola

        flask db migrate
        flask db upgrade

5. Correr la aplicaciÃ³n en consola

        python3 run.py

---

## ğŸ§© ExplicaciÃ³n de la base de datos usada

AquÃ­ se debe explicar quÃ© tipo de base de datos se utiliza (SQLite/MySQL), por quÃ© se eligiÃ³, cÃ³mo estÃ¡ estructurada la base (modelo entidad-relaciÃ³n si aplica) y cÃ³mo se realiza la conexiÃ³n usando SQLAlchemy.

Ejemplo:
- La base se conecta usando una URI definida en `.env`
- Cada entidad (curso, estudiante, etc.) es un modelo de SQLAlchemy
- Se usan claves forÃ¡neas para representar relaciones (ej. un estudiante puede estar inscrito en varios cursos)

---

## ğŸ“š Explicaciones de los puntos del enunciado

### ğŸ“ CRUD de Cursos

ExplicaciÃ³n de cÃ³mo se implementa el modelo `Course`, las rutas disponibles (`GET`, `POST`, `PUT`, `DELETE`), validaciones, etc.

### ğŸ‘¨â€ğŸ“ CRUD de Estudiantes

ExplicaciÃ³n sobre el modelo `Student`, sus campos, validaciones, endpoints y cÃ³mo se manipulan desde la app (formulario, JSON, etc.).

### ğŸ‘©â€ğŸ« CRUD de Profesores

AquÃ­ se documenta el modelo de `Teacher` (si existe), junto con sus endpoints y lÃ³gica del CRUD.

### ğŸ“„ CRUD de Evaluaciones

ExplicaciÃ³n de cÃ³mo se maneja el modelo `Evaluation` o similar, su relaciÃ³n con cursos/estudiantes, y cÃ³mo se gestiona la informaciÃ³n.

### ğŸ”— Relaciones entre Entidades

AcÃ¡ se explica cÃ³mo se conectan las distintas entidades (ej. muchos-a-muchos entre cursos y estudiantes), usando `backref`, `secondary`, etc.

---

## âœ¨ Quality of Life tools

### Archivo `query.py`

El archivo `query.py` funge como un simulador de consola virtual de SQL. Se aÃ±ade al considerar que Flask no posee un mÃ©todo predefinido para acceder a la base de datos mediante lÃ­nea de comandos. Contiene snippets de cÃ³digo para inspeccionar el contenido de las tablas mientras se desarrolla.


        # Print all existing instances of a table

        print("Instances of table:")
        instances = Table.query.all()
        for instance in instances:
            print(f"- {instance.id}: {instance.data}") 

para ejecutarlo solo se tienen que [ejecutar las migraciones correspondientes](#migrate_database) con anterioridad y luego usar el comando para ejecutar el archivo .py

        python3 query.py

## Cambios por Vicente Acevedo

Primero, si bien prefiero hacer un readme que incluya toda la lÃ³gica a usar, tambiÃ©n considero sano aÃ±adir en el cÃ³digo los comentarios respectivos. Podemos conversar despuÃ©s la eliminaciÃ³n de redundancias en un posterior proceso de refactoring.

<h4> Run.py </h4>

1. AÃ±adÃ­ el mÃ©todo "host" a la funciÃ³n que inicializa el servidor (app.run) con el parÃ¡metro 0.0.0.0. SegÃºn el video guÃ­a que vÃ­, esto permite acceder desde local_host y desde ip's compartidad -algo asÃ­-. El cÃ³digo es el siguiente.

        if __name__ == '__main__': 
        
                app.run(host = '0.0.0.0', debug=True)

2. AÃ±adÃ­ una landing page que llama desde template un html que llamÃ© main. Esto es mÃ¡s que nada porque cuando abrÃ­a la aplicaciÃ³n no habÃ­a nada disponible, lo que me dificultaba a la hora de imaginar el workflow porque no tenÃ­a un punto de entrada fijo. Los cambios y el enrutamiento que hacen posible esto son los siguientes, lo hice de la siguiente forma -siguiendo el video explicativo que comentÃ© anteriormente-.


        
        from flask import render_template #Allows the use of templates

        @app.route('/')
        def landing_page():
                return render_template('main.html') #Location is templates/main.html


La idea del **landing page** serÃ­a manejar la lÃ³gica de usuario, pero para los propÃ³sitos de esta entrega aÃºn no es necesario implementar aquello. Por eso, prefiero mantenerla sin nada. Me imagino que ante la necesidad de aÃ±adir sesiones, se pueden pasar como parÃ¡metros las credenciales para la identificaciÃ³n.

AsÃ­, lo actualicÃ© para que solo reciba las variables necesarias de la base de datos para visualizar toda la informaciÃ³n.

        from app.models.course import Course #Imports from DB
        from app.models.student import Student #Imports from DB

        @app.route('/')
        def landing_page():

        courses = Course.query.all() #Access all course instances as course variable
        students = Student.query.all() #Access all students instances as students variable

        return render_template('main.html', courses =courses, students=students) #Location is templates/main.html, adds variables to template

Lo que quedarÃ­a por hacer ahora es generar una vista que organice las tablas accesibles y permita mirar los datos. Luego, aÃ±adir mÃ©todos CRUD con respectivas vistas. Esto se puede hacer con template y blocks. Es lo que pretendo hacer por la tarde. <-- *anotaciÃ³n hecha el 7/04 a las 11:11, pide un deseo!*

Pero recomiendo tener una landing page general con tablas que representen cada una de las instancias de forma ordenada y asÃ­ poder acceder a los mÃ©todos. Luego, una vista especÃ­fica.

**De momento el frontend no parece ser relevante, me parece mÃ¡s importante conectar los mÃ©todos y hacer que el backend funcione, de ahÃ­ a que no he estilizado nada**.