# DiseÃ±o de Software Verificable - Sistema de GestiÃ³n AcadÃ©mica (SGA)

Este proyecto es una implementaciÃ³n de un Sistema de GestiÃ³n AcadÃ©mica (SGA), desarrollado como parte del curso "DiseÃ±o de Software Verificable". El sistema tiene como objetivo principal gestionar cursos, profesores, alumnos, evaluaciones y sus relaciones. Utiliza Python 3.9+, Flask como framework web y MySQL como base de datos.

La arquitectura estÃ¡ diseÃ±ada para ser mantenible y escalable, utilizando patrones como aplicaciÃ³n modular, SQLAlchemy para ORM y migraciones controladas con Flask-Migrate.

---

## Contenidos

- [DiseÃ±o de Software Verificable - Sistema de GestiÃ³n AcadÃ©mica (SGA)](#diseÃ±o-de-software-verificable---sistema-de-gestiÃ³n-acadÃ©mica-sga)
  - [Contenidos](#contenidos)
  - [ğŸ“Œ Instrucciones de uso](#-instrucciones-de-uso)
  - [ğŸ§© ExplicaciÃ³n de la base de datos usada](#-explicaciÃ³n-de-la-base-de-datos-usada)
  - [ğŸ“š Explicaciones de los puntos del enunciado](#-explicaciones-de-los-puntos-del-enunciado)
    - [ğŸ“ CRUD de Cursos](#-crud-de-cursos)
    - [ğŸ‘¨â€ğŸ“ CRUD de Estudiantes](#-crud-de-estudiantes)
    - [ğŸ‘©â€ğŸ« CRUD de Profesores](#-crud-de-profesores)
    - [ğŸ“„ CRUD de Evaluaciones](#-crud-de-evaluaciones)
    - [ğŸ”— Relaciones entre Entidades](#-relaciones-entre-entidades)
  - [âœ¨ Quality of Life tools](#-quality-of-life-tools)
    - [Archivo `query.py`](#archivo-querypy)
  - [Cambios por Vicente Acevedo](#cambios-por-vicente-acevedo)

---

## ğŸ“Œ Instrucciones de uso

1. Clonar el repositorio:

        git clone #PONER EL LINK ACÃ

2. Definir un archivo .env con la variable de base de datos:

        DATABASE_URI=sqlite:///dev.db #Usamos SQLITe por lo que este es el que estÃ¡ predefinido

3. Inicializar la base de datos en consola

        flask db init

4. <a name="migrate_database"></a> Actualizar la base de datos en consola

        flask db migrate
        flask db upgrade

5. Correr la aplicaciÃ³n en consola

        python3 run.py

---

## ğŸ§© ExplicaciÃ³n de la base de datos usada

AquÃ­ se debe explicar quÃ© tipo de base de datos se utiliza (SQLite/MySQL), por quÃ© se eligiÃ³, cÃ³mo estÃ¡ estructurada la base (modelo entidad-relaciÃ³n si aplica) y cÃ³mo se realiza la conexiÃ³n usando SQLAlchemy.

Ejemplo:
- La base se conecta usando una URI definida en `.env`
- Cada entidad (curso, estudiante, etc.) es un modelo de SQLAlchemy
- Se usan claves forÃ¡neas para representar relaciones (ej. un estudiante puede estar inscrito en varios cursos)

---

## ğŸ“š Explicaciones de los puntos del enunciado

### ğŸ“ CRUD de Cursos

ExplicaciÃ³n de cÃ³mo se implementa el modelo `Course`, las rutas disponibles (`GET`, `POST`, `PUT`, `DELETE`), validaciones, etc.

### ğŸ‘¨â€ğŸ“ CRUD de Estudiantes

ExplicaciÃ³n sobre el modelo `Student`, sus campos, validaciones, endpoints y cÃ³mo se manipulan desde la app (formulario, JSON, etc.).

### ğŸ‘©â€ğŸ« CRUD de Profesores

AquÃ­ se documenta el modelo de `Teacher` (si existe), junto con sus endpoints y lÃ³gica del CRUD.

### ğŸ“„ CRUD de Evaluaciones

ExplicaciÃ³n de cÃ³mo se maneja el modelo `Evaluation` o similar, su relaciÃ³n con cursos/estudiantes, y cÃ³mo se gestiona la informaciÃ³n.

### ğŸ”— Relaciones entre Entidades

AcÃ¡ se explica cÃ³mo se conectan las distintas entidades (ej. muchos-a-muchos entre cursos y estudiantes), usando `backref`, `secondary`, etc.

---

## âœ¨ Quality of Life tools

### Archivo `query.py`

El archivo `query.py` funge como un simulador de consola virtual de SQL. Se aÃ±ade al considerar que Flask no posee un mÃ©todo predefinido para acceder a la base de datos mediante lÃ­nea de comandos. Contiene snippets de cÃ³digo para inspeccionar el contenido de las tablas mientras se desarrolla.


        # Print all existing instances of a table

        print("Instances of table:")
        instances = Table.query.all()
        for instance in instances:
            print(f"- {instance.id}: {instance.data}") 

para ejecutarlo solo se tienen que [ejecutar las migraciones correspondientes](#migrate_database) con anterioridad y luego usar el comando para ejecutar el archivo .py

        python3 query.py

## Cambios por Vicente Acevedo

Primero, si bien prefiero hacer un readme que incluya toda la lÃ³gica a usar, tambiÃ©n considero sano aÃ±adir en el cÃ³digo los comentarios respectivos. Podemos conversar despuÃ©s la eliminaciÃ³n de redundancias en un posterior proceso de refactoring.

<h4> Run.py </h4>

1. AÃ±adÃ­ el mÃ©todo "host" a la funciÃ³n que inicializa el servidor (app.run) con el parÃ¡metro 0.0.0.0. SegÃºn el video guÃ­a que vÃ­, esto permite acceder desde local_host y desde ip's compartidad -algo asÃ­-. El cÃ³digo es el siguiente.

        if __name__ == '__main__': 
        
                app.run(host = '0.0.0.0', debug=True)

2. AÃ±adÃ­ una landing page que llama desde template un html que llamÃ© main. Esto es mÃ¡s que nada porque cuando abrÃ­a la aplicaciÃ³n no habÃ­a nada disponible, lo que me dificultaba a la hora de imaginar el workflow porque no tenÃ­a un punto de entrada fijo. Los cambios y el enrutamiento que hacen posible esto son los siguientes, lo hice de la siguiente forma -siguiendo el video explicativo que comentÃ© anteriormente-.


        
        from flask import render_template #Allows the use of templates

        @app.route('/')
        def landing_page():
                return render_template('main.html') #Location is templates/main.html


La idea del **landing page** serÃ­a manejar la lÃ³gica de usuario, pero para los propÃ³sitos de esta entrega aÃºn no es necesario implementar aquello. Por eso, prefiero mantenerla sin nada. Me imagino que ante la necesidad de aÃ±adir sesiones, se pueden pasar como parÃ¡metros las credenciales para la identificaciÃ³n.

AsÃ­, lo actualicÃ© para que solo reciba las variables necesarias de la base de datos para visualizar toda la informaciÃ³n.

        from app.models.course import Course #Imports from DB
        from app.models.student import Student #Imports from DB

        @app.route('/')
        def landing_page():

        courses = Course.query.all() #Access all course instances as course variable
        students = Student.query.all() #Access all students instances as students variable

        return render_template('main.html', courses =courses, students=students) #Location is templates/main.html, adds variables to template

Lo que quedarÃ­a por hacer ahora es generar una vista que organice las tablas accesibles y permita mirar los datos. Luego, aÃ±adir mÃ©todos CRUD con respectivas vistas. Esto se puede hacer con template y blocks. Es lo que pretendo hacer por la tarde. <-- *anotaciÃ³n hecha el 7/04 a las 11:11, pide un deseo!*

Pero recomiendo tener una landing page general con tablas que representen cada una de las instancias de forma ordenada y asÃ­ poder acceder a los mÃ©todos. Luego, una vista especÃ­fica.

**De momento el frontend no parece ser relevante, me parece mÃ¡s importante conectar los mÃ©todos y hacer que el backend funcione, de ahÃ­ a que no he estilizado nada**.


## Cambios por Chiara Romanini

### Models
Los modelos es donde se definen los atributos de las tablas. El nombre de la tabla se define en plural de la siguiente manera:
```
__tablename__='evaluations'
```

Una llave forÃ¡nea se define de la siguiente manera:
```
course_section_id = db.Column(db.Integer, db.ForeignKey('course_sections.id'), nullable=False)
```
En este ejemplo, se estÃ¡ definiendo que course_section_id es una llave forÃ¡nea que apunta a la entidad 'CourseSection', donde su valor es el id de esta tabla.

#### Relaciones 
Las tablas desarrolladas tienen dos tipos de relaciones: las tablas que se unen a travÃ©s de una llave forÃ¡nea, y las tablas que actÃºan como una tabla intermedia para una relaciÃ³n de muchos a muchos.

En el primer caso, donde la relaciÃ³n entre las entidades es de uno a muchos, la relaciÃ³n se tiene que definir en el modelo donde la relaciÃ³n es "uno". Por ejemplo:
- Course y CourseSection tienen una relaciÃ³n uno a muchos, donde Course puede tener muchos CourseSections, pero CourseSection solo pertenece a un Course. En este caso, la relaciÃ³n se tiene que definir en el modelo de Course (la entidad que representa la relaciÃ³n de "uno"). La relaciÃ³n entre ambas entidades se define de la siguiente manera:

```
# En archivo models/course.py

sections = db.relationship('CourseSection', backref='course', lazy=True)
```

Gracias al atributo "backref", no es necesario definir la relaciÃ³n en la otra entidad CourseSection. Con esto, la relaciÃ³n queda establecida y se pueden realizar consultas de la siguiente naturaleza:

```
course = Course.get(1)

for section in course.sections:
        print(section.nrc)

# course.sections en este caso es una lista con todos las secciones que pertenecen al curso definido
```

Gracias al atributo "backref", tambien se pueden hacer este tipo de consultas:
```
course_section = CourseSection.get(1)

course_section.course.name # Esto muestra el nombre del curso 
```

El segundo caso es el de las tablas intermedias que representan las relaciones muchos a muchos, como lo es el caso de StudentCourses. Esta tabla se encarga de relacionar las entidades Student y CourseSection. Para esto, en el modelo de StudentCourses se tiene que establecer la relaciÃ³n con estas dos entidades, de la siguiente manera:

```
# En models/student_course.py

student = db.relationship('Student', back_populates='student_courses')
course_section = db.relationship('CourseSection', back_populates='student_courses')
```

Luego en el archivo de estas entidades (student.py y course_section.py) se tiene que establecer la misma relaciÃ³n pero hacia la tabla StudentCourses.
```
# En models/student.py

student_courses = db.relationship('StudentCourses', back_populates='student')
```

Lo mismo para CourseSection
```
# En models/course_section.py

student_courses = db.relationship('StudentCourses', back_populates='course_section')
```

Con esto, las consultas para obtener a los estudiantes de una secciÃ³n serÃ­a de la siguiente manera:
```
section = CourseSection.get(1)
students = section.student_courses.students
```

Para simplificar esta consulta, se escribiÃ³ una propiedad en cada una de las entidades con esta estructura:
```
# En models/course_section.py

@property
    def students(self):
        return [sc.student for sc in self.student_courses]
```

Con esto, las consultas se pueden realizar de la siguiente manera:
```
section = CourseSection.get(1)
students = section.students
```

Esto mismo se realizÃ³ para los estudiantes, y se puede ver en el archivo models/students.py


### Controllers
En los archivos de los controladores se encuentra el CRUD (CRU tÃ©cnicamente porque falta Delete) de las entidades Course, CourseSection, Evaluation, EvaluationType, Student, Teacher y StudentCourse. 

Estos controladores son los encargados de las funciones principales.

### Routes
En las rutas es donde se definen las rutas xd. Para estos archivos, intentÃ© que de la lÃ³gica se encargaran las funciones definidas en los controladores. Por ejemplo, el GET tiene esta estructura:

```
# En el archivo routes/course_routes.py

@course_bp.route('/', methods=['GET'])
def getCoursesView():
    courses = getAllCourses()
    return render_template('courses/index.html', courses=courses)
```

Como se puede ver, en vez de realizar la consulta en esta misma funciÃ³n, se llama a la funciÃ³n getAllCourses() que se encuentra definida en el controlador. Si bien puede que para esta vista no afecte realizar la consulta ahi mismo, creo que en el futuro cuando tengamos que realizar mÃ¡s lÃ³gica y validaciones se puede empezar a desordenar el cÃ³digo, es por esto que encuentro mejor dejar toda la lÃ³gica para los controladores, y las rutas solo se encargan de llamar a estas funciones. 

### app/__init__.py
En este archivo, se tiene que agregar las rutas (blueprint) de los modelos nuevos que se creen. Por ejemplo, para Evaluation: 

```
# En archivo app/__init__.py

from app.routes.evaluation_routes import evaluation_bp
app.register_blueprint(evaluation_bp)
```

## Flujo pensado para la aplicaciÃ³n
Por ahora, si bien no hay un flujo bien definido, fuÃ­ desarrollando las entidades para que se vea de la siguiente manera:
1. "PÃ¡gina principal" son los cursos (localhost/courses)
2. Desde esta vista se puede ingresar a un curso en especÃ­fico.
3. En la vista de Curso, se pueden ver sus secciones (CourseSection)
4. Al ingresar a una secciÃ³n, se puede ver los estudiantes que pertenecen a esa secciÃ³n, los tipos de evaluaciÃ³n de esa secciÃ³n (EvaluationType) y las evaluaciones de la secciÃ³n (Evaluation).


Para el CRUD de los estudiantes y profesores, por ahora se tiene que manualmente ingresar la rutas respectivas de estas entidades (/students y /teachers).