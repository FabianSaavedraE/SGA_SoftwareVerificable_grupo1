# Dise√±o de Software Verificable - Sistema de Gesti√≥n Acad√©mica (SGA)

Este proyecto es una implementaci√≥n de un Sistema de Gesti√≥n Acad√©mica (SGA), desarrollado como parte del curso "Dise√±o de Software Verificable". El sistema tiene como objetivo principal gestionar cursos, profesores, alumnos, evaluaciones y sus relaciones. Utiliza Python 3.9+, Flask como framework web y MySQL como base de datos.

La arquitectura est√° dise√±ada para ser mantenible y escalable, utilizando patrones como aplicaci√≥n modular, SQLAlchemy para ORM y migraciones controladas con Flask-Migrate.

---

## Contenidos

- [Dise√±o de Software Verificable - Sistema de Gesti√≥n Acad√©mica (SGA)](#dise√±o-de-software-verificable---sistema-de-gesti√≥n-acad√©mica-sga)
  - [Contenidos](#contenidos)
  - [üìå Instrucciones de uso](#-instrucciones-de-uso)
  - [üß© Explicaci√≥n de la base de datos usada](#-explicaci√≥n-de-la-base-de-datos-usada)
  - [üìö Explicaciones de los puntos del enunciado](#-explicaciones-de-los-puntos-del-enunciado)
    - [üìÅ CRUD de Cursos](#-crud-de-cursos)
    - [üë®‚Äçüéì CRUD de Estudiantes](#-crud-de-estudiantes)
    - [üë©‚Äçüè´ CRUD de Profesores](#-crud-de-profesores)
    - [üìÑ CRUD de Evaluaciones](#-crud-de-evaluaciones)
    - [üîó Relaciones entre Entidades](#-relaciones-entre-entidades)
  - [‚ú® Quality of Life tools](#-quality-of-life-tools)
    - [Archivo `query.py`](#archivo-querypy)
  - [Cambios por Vicente Acevedo](#cambios-por-vicente-acevedo)
  - [Cambios por Chiara Romanini](#cambios-por-chiara-romanini)
    - [Models](#models)
      - [Relaciones](#relaciones)
    - [Controllers](#controllers)
    - [Routes](#routes)
    - [app/__init__.py](#appinitpy)
  - [Flujo pensado para la aplicaci√≥n](#flujo-pensado-para-la-aplicaci√≥n)

---

## üìå Instrucciones de uso

1. Clonar el repositorio:

        git clone #PONER EL LINK AC√Å

2. Definir un archivo .env con la variable de base de datos:

        DATABASE_URI=sqlite:///dev.db #Usamos SQLITe por lo que este es el que est√° predefinido

3. Inicializar la base de datos en consola

        flask db init

4. <a name="migrate_database"></a> Actualizar la base de datos en consola

        flask db migrate
        flask db upgrade

5. Correr la aplicaci√≥n en consola

        python3 run.py

---

## üß© Explicaci√≥n de la base de datos usada

Aqu√≠ se debe explicar qu√© tipo de base de datos se utiliza (SQLite/MySQL), por qu√© se eligi√≥, c√≥mo est√° estructurada la base (modelo entidad-relaci√≥n si aplica) y c√≥mo se realiza la conexi√≥n usando SQLAlchemy.

Ejemplo:
- La base se conecta usando una URI definida en `.env`
- Cada entidad (curso, estudiante, etc.) es un modelo de SQLAlchemy
- Se usan claves for√°neas para representar relaciones (ej. un estudiante puede estar inscrito en varios cursos)

---

## üìö Explicaciones de los puntos del enunciado

### üìÅ CRUD de Cursos

Explicaci√≥n de c√≥mo se implementa el modelo `Course`, las rutas disponibles (`GET`, `POST`, `PUT`, `DELETE`), validaciones, etc.

### üë®‚Äçüéì CRUD de Estudiantes

Explicaci√≥n sobre el modelo `Student`, sus campos, validaciones, endpoints y c√≥mo se manipulan desde la app (formulario, JSON, etc.).

### üë©‚Äçüè´ CRUD de Profesores

Aqu√≠ se documenta el modelo de `Teacher` (si existe), junto con sus endpoints y l√≥gica del CRUD.

### üìÑ CRUD de Evaluaciones

Explicaci√≥n de c√≥mo se maneja el modelo `Evaluation` o similar, su relaci√≥n con cursos/estudiantes, y c√≥mo se gestiona la informaci√≥n.

### üîó Relaciones entre Entidades

Ac√° se explica c√≥mo se conectan las distintas entidades (ej. muchos-a-muchos entre cursos y estudiantes), usando `backref`, `secondary`, etc.

---

## ‚ú® Quality of Life tools

### Archivo `query.py`

El archivo `query.py` funge como un simulador de consola virtual de SQL. Se a√±ade al considerar que Flask no posee un m√©todo predefinido para acceder a la base de datos mediante l√≠nea de comandos. Contiene snippets de c√≥digo para inspeccionar el contenido de las tablas mientras se desarrolla.


        # Print all existing instances of a table

        print("Instances of table:")
        instances = Table.query.all()
        for instance in instances:
            print(f"- {instance.id}: {instance.data}") 

para ejecutarlo solo se tienen que [ejecutar las migraciones correspondientes](#migrate_database) con anterioridad y luego usar el comando para ejecutar el archivo .py

        python3 query.py

## Cambios por Vicente Acevedo

Primero, si bien prefiero hacer un readme que incluya toda la l√≥gica a usar, tambi√©n considero sano a√±adir en el c√≥digo los comentarios respectivos. Podemos conversar despu√©s la eliminaci√≥n de redundancias en un posterior proceso de refactoring.

<h4> Run.py </h4>

1. A√±ad√≠ el m√©todo "host" a la funci√≥n que inicializa el servidor (app.run) con el par√°metro 0.0.0.0. Seg√∫n el video gu√≠a que v√≠, esto permite acceder desde local_host y desde ip's compartidad -algo as√≠-. El c√≥digo es el siguiente.

        if __name__ == '__main__': 
        
                app.run(host = '0.0.0.0', debug=True)

2. A√±ad√≠ una landing page que llama desde template un html que llam√© main. Esto es m√°s que nada porque cuando abr√≠a la aplicaci√≥n no hab√≠a nada disponible, lo que me dificultaba a la hora de imaginar el workflow porque no ten√≠a un punto de entrada fijo. Los cambios y el enrutamiento que hacen posible esto son los siguientes, lo hice de la siguiente forma -siguiendo el video explicativo que coment√© anteriormente-.


        
        from flask import render_template #Allows the use of templates

        @app.route('/')
        def landing_page():
                return render_template('main.html') #Location is templates/main.html


La idea del **landing page** ser√≠a manejar la l√≥gica de usuario, pero para los prop√≥sitos de esta entrega a√∫n no es necesario implementar aquello. Por eso, prefiero mantenerla sin nada. Me imagino que ante la necesidad de a√±adir sesiones, se pueden pasar como par√°metros las credenciales para la identificaci√≥n.

As√≠, lo actualic√© para que solo reciba las variables necesarias de la base de datos para visualizar toda la informaci√≥n.

        from app.models.course import Course #Imports from DB
        from app.models.student import Student #Imports from DB

        @app.route('/')
        def landing_page():

        courses = Course.query.all() #Access all course instances as course variable
        students = Student.query.all() #Access all students instances as students variable

        return render_template('main.html', courses =courses, students=students) #Location is templates/main.html, adds variables to template

Lo que quedar√≠a por hacer ahora es generar una vista que organice las tablas accesibles y permita mirar los datos. Luego, a√±adir m√©todos CRUD con respectivas vistas. Esto se puede hacer con template y blocks. Es lo que pretendo hacer por la tarde. <-- *anotaci√≥n hecha el 7/04 a las 11:11, pide un deseo!*

Pero recomiendo tener una landing page general con tablas que representen cada una de las instancias de forma ordenada y as√≠ poder acceder a los m√©todos. Luego, una vista espec√≠fica.

**De momento el frontend no parece ser relevante, me parece m√°s importante conectar los m√©todos y hacer que el backend funcione, de ah√≠ a que no he estilizado nada**.

Para facilitar los accesos, vincul√© el frontend de todo mediante el landing page. All√≠ a√±ad√≠ los m√©todos (basados en los snipets de c√≥digo anteriores) para acceder a los otros elementos importantes de la base de datos (teachers y student_sections) para ligar todas las vistas desde el origen del modelo.

La vista de main.html entonces cuenta con 4 cajas en una grid con botones respectivos que permiten acceder a las secciones de la siguiente forma:

            <!-- Estudiantes -->
            <div class="box"> 
                {% if students %}
                <a href="{{ url_for('students.getStudentsView') }}">
                    <button>Ver estudiantes</button>
                </a>
                {% endif %}
                <ul>
                    {% for student in students %}
                        <li>{{ student.first_name }} {{ student.last_name }}</li>
                    {% else %}
                        <li>No hay estudiantes</li>
                    {% endfor %}
                </ul>
            </div>

Box posee el atributo que permite deslizar dentro de la estructura en caso de que haya sobrepasado el tama√±o apropiado para el contenido. El bot√≥n lleva a la vista respectiva de estudiantes, y se muestran los estudiantes. Se a√±aden los ifs para no generar un bot√≥n inutil en caso de que no hayan estudiantes.

## Cambios por Chiara Romanini

### Models
Los modelos es donde se definen los atributos de las tablas. El nombre de la tabla se define en plural de la siguiente manera:
```
__tablename__='evaluations'
```

Una llave for√°nea se define de la siguiente manera:
```
course_section_id = db.Column(db.Integer, db.ForeignKey('course_sections.id'), nullable=False)
```
En este ejemplo, se est√° definiendo que course_section_id es una llave for√°nea que apunta a la entidad 'CourseSection', donde su valor es el id de esta tabla.

#### Relaciones 
Las tablas desarrolladas tienen dos tipos de relaciones: las tablas que se unen a trav√©s de una llave for√°nea, y las tablas que act√∫an como una tabla intermedia para una relaci√≥n de muchos a muchos.

En el primer caso, donde la relaci√≥n entre las entidades es de uno a muchos, la relaci√≥n se tiene que definir en el modelo donde la relaci√≥n es "uno". Por ejemplo:
- Course y CourseSection tienen una relaci√≥n uno a muchos, donde Course puede tener muchos CourseSections, pero CourseSection solo pertenece a un Course. En este caso, la relaci√≥n se tiene que definir en el modelo de Course (la entidad que representa la relaci√≥n de "uno"). La relaci√≥n entre ambas entidades se define de la siguiente manera:

```
# En archivo models/course.py

sections = db.relationship('CourseSection', backref='course', lazy=True)
```

Gracias al atributo "backref", no es necesario definir la relaci√≥n en la otra entidad CourseSection. Con esto, la relaci√≥n queda establecida y se pueden realizar consultas de la siguiente naturaleza:

```
course = Course.get(1)

for section in course.sections:
        print(section.nrc)

# course.sections en este caso es una lista con todos las secciones que pertenecen al curso definido
```

Gracias al atributo "backref", tambien se pueden hacer este tipo de consultas:
```
course_section = CourseSection.get(1)

course_section.course.name # Esto muestra el nombre del curso 
```

El segundo caso es el de las tablas intermedias que representan las relaciones muchos a muchos, como lo es el caso de StudentCourses. Esta tabla se encarga de relacionar las entidades Student y CourseSection. Para esto, en el modelo de StudentCourses se tiene que establecer la relaci√≥n con estas dos entidades, de la siguiente manera:

```
# En models/student_course.py

student = db.relationship('Student', back_populates='student_courses')
course_section = db.relationship('CourseSection', back_populates='student_courses')
```

Luego en el archivo de estas entidades (student.py y course_section.py) se tiene que establecer la misma relaci√≥n pero hacia la tabla StudentCourses.
```
# En models/student.py

student_courses = db.relationship('StudentCourses', back_populates='student')
```

Lo mismo para CourseSection
```
# En models/course_section.py

student_courses = db.relationship('StudentCourses', back_populates='course_section')
```

Con esto, las consultas para obtener a los estudiantes de una secci√≥n ser√≠a de la siguiente manera:
```
section = CourseSection.get(1)
students = section.student_courses.students
```

Para simplificar esta consulta, se escribi√≥ una propiedad en cada una de las entidades con esta estructura:
```
# En models/course_section.py

@property
    def students(self):
        return [sc.student for sc in self.student_courses]
```

Con esto, las consultas se pueden realizar de la siguiente manera:
```
section = CourseSection.get(1)
students = section.students
```

Esto mismo se realiz√≥ para los estudiantes, y se puede ver en el archivo models/students.py


### Controllers
En los archivos de los controladores se encuentra el CRUD (CRU t√©cnicamente porque falta Delete) de las entidades Course, CourseSection, Evaluation, EvaluationType, Student, Teacher y StudentCourse. 

Estos controladores son los encargados de las funciones principales.

### Routes
En las rutas es donde se definen las rutas xd. Para estos archivos, intent√© que de la l√≥gica se encargaran las funciones definidas en los controladores. Por ejemplo, el GET tiene esta estructura:

```
# En el archivo routes/course_routes.py

@course_bp.route('/', methods=['GET'])
def getCoursesView():
    courses = getAllCourses()
    return render_template('courses/index.html', courses=courses)
```

Como se puede ver, en vez de realizar la consulta en esta misma funci√≥n, se llama a la funci√≥n getAllCourses() que se encuentra definida en el controlador. Si bien puede que para esta vista no afecte realizar la consulta ahi mismo, creo que en el futuro cuando tengamos que realizar m√°s l√≥gica y validaciones se puede empezar a desordenar el c√≥digo, es por esto que encuentro mejor dejar toda la l√≥gica para los controladores, y las rutas solo se encargan de llamar a estas funciones. 

### app/__init__.py
En este archivo, se tiene que agregar las rutas (blueprint) de los modelos nuevos que se creen. Por ejemplo, para Evaluation: 

```
# En archivo app/__init__.py

from app.routes.evaluation_routes import evaluation_bp
app.register_blueprint(evaluation_bp)
```

## Flujo pensado para la aplicaci√≥n
Por ahora, si bien no hay un flujo bien definido, fu√≠ desarrollando las entidades para que se vea de la siguiente manera:
1. "P√°gina principal" son los cursos (localhost/courses)
2. Desde esta vista se puede ingresar a un curso en espec√≠fico.
3. En la vista de Curso, se pueden ver sus secciones (CourseSection)
4. Al ingresar a una secci√≥n, se puede ver los estudiantes que pertenecen a esa secci√≥n, los tipos de evaluaci√≥n de esa secci√≥n (EvaluationType) y las evaluaciones de la secci√≥n (Evaluation).


Para el CRUD de los estudiantes y profesores, por ahora se tiene que manualmente ingresar la rutas respectivas de estas entidades (/students y /teachers).