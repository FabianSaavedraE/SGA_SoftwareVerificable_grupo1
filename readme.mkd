# Dise√±o de Software Verificable - Sistema de Gesti√≥n Acad√©mica (SGA)

Este proyecto es una implementaci√≥n de un Sistema de Gesti√≥n Acad√©mica (SGA), desarrollado como parte del curso "Dise√±o de Software Verificable". El sistema tiene como objetivo principal gestionar cursos, profesores, alumnos, evaluaciones y sus relaciones. Utiliza Python 3.9+, Flask como framework web y MySQL como base de datos.

La arquitectura est√° dise√±ada para ser mantenible y escalable, utilizando patrones como aplicaci√≥n modular, SQLAlchemy para ORM y migraciones controladas con Flask-Migrate.

---

## Contenidos

- [Dise√±o de Software Verificable - Sistema de Gesti√≥n Acad√©mica (SGA)](#dise√±o-de-software-verificable---sistema-de-gesti√≥n-acad√©mica-sga)
  - [Contenidos](#contenidos)
  - [üìå Instrucciones de uso](#-instrucciones-de-uso)
  - [üß© Explicaci√≥n de la base de datos usada](#-explicaci√≥n-de-la-base-de-datos-usada)
  - [üìö Explicaciones de los puntos del enunciado](#-explicaciones-de-los-puntos-del-enunciado)
    - [üìÅ CRUD de Cursos](#-crud-de-cursos)
    - [üë®‚Äçüéì CRUD de Estudiantes](#-crud-de-estudiantes)
    - [üë©‚Äçüè´ CRUD de Profesores](#-crud-de-profesores)
    - [üìÑ CRUD de Evaluaciones](#-crud-de-evaluaciones)
    - [üîó Relaciones entre Entidades](#-relaciones-entre-entidades)
  - [‚ú® Quality of Life tools](#-quality-of-life-tools)
  - [Cambios por Vicente Acevedo](#cambios-por-vicente-acevedo)
  - [Cambios por Chiara Romanini](#cambios-por-chiara-romanini)
    - [Models](#models)
      - [Relaciones](#relaciones)
    - [Controllers](#controllers)
    - [Routes](#routes)
    - [app/__init__.py](#appinitpy)
  - [Flujo pensado para la aplicaci√≥n](#flujo-pensado-para-la-aplicaci√≥n)

---

## üìå Instrucciones de uso

1. Clonar el repositorio:

        git clone #PONER EL LINK AC√Å

2. Definir un archivo .env con la variable de base de datos:

        DATABASE_URI=mysql://USUARIO:CONTRASE√ëA@localhost:3306/NOMBRE_DB #Remplazar la informaci√≥n de USUARIO, CONTRASE√ëA y NOMBRE_DB con la informaci√≥n de la bdd de MySQL contruida en la maquina local

3. Inicializar la base de datos en consola

        flask db init

4. <a name="migrate_database"></a> Actualizar la base de datos en consola

        flask db migrate
        flask db upgrade

5. Correr la aplicaci√≥n en consola

        python3 run.py

---

## üß© Explicaci√≥n de la base de datos usada

Aqu√≠ se debe explicar qu√© tipo de base de datos se utiliza (SQLite/MySQL), por qu√© se eligi√≥, c√≥mo est√° estructurada la base (modelo entidad-relaci√≥n si aplica) y c√≥mo se realiza la conexi√≥n usando SQLAlchemy.

Ejemplo:
- La base se conecta usando una URI definida en `.env`
- Cada entidad (curso, estudiante, etc.) es un modelo de SQLAlchemy
- Se usan claves for√°neas para representar relaciones (ej. un estudiante puede estar inscrito en varios cursos)

---

## üìö Explicaciones de los puntos del enunciado

### üìÅ CRUD de Cursos

Explicaci√≥n de c√≥mo se implementa el modelo `Course`, las rutas disponibles (`GET`, `POST`, `PUT`, `DELETE`), validaciones, etc.

### üë®‚Äçüéì CRUD de Estudiantes

Explicaci√≥n sobre el modelo `Student`, sus campos, validaciones, endpoints y c√≥mo se manipulan desde la app (formulario, JSON, etc.).

### üë©‚Äçüè´ CRUD de Profesores

Aqu√≠ se documenta el modelo de `Teacher` (si existe), junto con sus endpoints y l√≥gica del CRUD.

### üìÑ CRUD de Evaluaciones

Explicaci√≥n de c√≥mo se maneja el modelo `Evaluation` o similar, su relaci√≥n con cursos/estudiantes, y c√≥mo se gestiona la informaci√≥n.

### üîó Relaciones entre Entidades

Ac√° se explica c√≥mo se conectan las distintas entidades (ej. muchos-a-muchos entre cursos y estudiantes), usando `backref`, `secondary`, etc.

---

## ‚ú® Quality of Life tools

<h3> Archivo `query.py` </h3>

El archivo `query.py` funge como un simulador de consola virtual de SQL. Se a√±ade al considerar que Flask no posee un m√©todo predefinido para acceder a la base de datos mediante l√≠nea de comandos. Contiene snippets de c√≥digo para inspeccionar el contenido de las tablas mientras se desarrolla.


        # Print all existing instances of a table

        print("Instances of table:")
        instances = Table.query.all()
        for instance in instances:
            print(f"- {instance.id}: {instance.data}") 

para ejecutarlo solo se tienen que [ejecutar las migraciones correspondientes](#migrate_database) con anterioridad y luego usar el comando para ejecutar el archivo .py

        python3 query.py

<h3> Archivo 'seed.py' </h3>

El archivo `seed.py` funciona como el archivo de seed de ruby on rails -para poner en un t√©rminos de framework conocido-, cargando datos mock a la base de datos para testear elementos de frontend y una vinculaci√≥n correcta con el backend. Para esto se define la siguiente estructura.

        from app import create_app, db
        from app.models.student import Student
        from app.models.course import Course
        from app.models.course_section import CourseSection
        from app.models.teacher import Teacher

        app = create_app()

        with app.app_context():
        # Re-instantiate the database.
        db.drop_all()
        db.create_all()
        print("Database reset (tables dropped and recreated).")

        # Creating 5 students.
        
        # Creating 5 courses.
        
        # Create a teacher
        
        # Create 5 sections, one for each course

Las instancias de creaci√≥n no son mostradas en el readme porque siguen la estructura b√°sica de la base de datos y generar√≠a mucha redundancia.

Al ejecutar el archivo con el comando

        python3 seed.py

Se reinstancia la base de datos -es decir, se dropea- al repopularla con la informaci√≥n determinada en el archivo.

No es necesario hacer la migraci√≥n o el update porque la obtenci√≥n de estos datos no depende de esos comandos.

<hr>

**UPDATE**: De momento, en el seed se provee una lista de nombres y apellidos. El seed genera de forma procedural N alumnos aleatorios, adem√°s de contar con 5 profesores de la facultad pre-definidos con asignaciones a secciones al azar. Se a√±aden 10 prerequisitos l√≥gicos para hacer debugging y testeo.

<hr>

## Cambios por Vicente Acevedo

Primero, si bien prefiero hacer un readme que incluya toda la l√≥gica a usar, tambi√©n considero sano a√±adir en el c√≥digo los comentarios respectivos. Podemos conversar despu√©s la eliminaci√≥n de redundancias en un posterior proceso de refactoring.

<h4> Run.py </h4>

1. A√±ad√≠ el m√©todo "host" a la funci√≥n que inicializa el servidor (app.run) con el par√°metro 0.0.0.0. Seg√∫n el video gu√≠a que v√≠, esto permite acceder desde local_host y desde ip's compartidad -algo as√≠-. El c√≥digo es el siguiente.

        if __name__ == '__main__': 
        
                app.run(host = '0.0.0.0', debug=True)

2. A√±ad√≠ una landing page que llama desde template un html que llam√© main. Esto es m√°s que nada porque cuando abr√≠a la aplicaci√≥n no hab√≠a nada disponible, lo que me dificultaba a la hora de imaginar el workflow porque no ten√≠a un punto de entrada fijo. Los cambios y el enrutamiento que hacen posible esto son los siguientes, lo hice de la siguiente forma -siguiendo el video explicativo que coment√© anteriormente-.


        
        from flask import render_template #Allows the use of templates

        @app.route('/')
        def landing_page():
                return render_template('main.html') #Location is templates/main.html


La idea del **landing page** ser√≠a manejar la l√≥gica de usuario, pero para los prop√≥sitos de esta entrega a√∫n no es necesario implementar aquello. Por eso, prefiero mantenerla sin nada. Me imagino que ante la necesidad de a√±adir sesiones, se pueden pasar como par√°metros las credenciales para la identificaci√≥n.

As√≠, lo actualic√© para que solo reciba las variables necesarias de la base de datos para visualizar toda la informaci√≥n.

        from app.models.course import Course #Imports from DB
        from app.models.student import Student #Imports from DB

        @app.route('/')
        def landing_page():

        courses = Course.query.all() #Access all course instances as course variable
        students = Student.query.all() #Access all students instances as students variable

        return render_template('main.html', courses =courses, students=students) #Location is templates/main.html, adds variables to template

Lo que quedar√≠a por hacer ahora es generar una vista que organice las tablas accesibles y permita mirar los datos. Luego, a√±adir m√©todos CRUD con respectivas vistas. Esto se puede hacer con template y blocks. Es lo que pretendo hacer por la tarde. <-- *anotaci√≥n hecha el 7/04 a las 11:11, pide un deseo!*

Pero recomiendo tener una landing page general con tablas que representen cada una de las instancias de forma ordenada y as√≠ poder acceder a los m√©todos. Luego, una vista espec√≠fica.

**De momento el frontend no parece ser relevante, me parece m√°s importante conectar los m√©todos y hacer que el backend funcione, de ah√≠ a que no he estilizado nada**.

Para facilitar los accesos, vincul√© el frontend de todo mediante el landing page. All√≠ a√±ad√≠ los m√©todos (basados en los snipets de c√≥digo anteriores) para acceder a los otros elementos importantes de la base de datos para ligar todas las vistas desde el origen del modelo.

La vista de main.html entonces cuenta con 5 cajas en una grid con botones respectivos que permiten acceder a las secciones de la siguiente forma:

            <!-- Estudiantes -->
            <div class="box"> 
                {% if students %}
                <a href="{{ url_for('students.getStudentsView') }}">
                    <button>Ver estudiantes</button>
                </a>
                {% endif %}
                <ul>
                    {% for student in students %}
                        <li>{{ student.first_name }} {{ student.last_name }}</li>
                    {% else %}
                        <li>No hay estudiantes</li>
                    {% endfor %}
                </ul>
            </div>

Box posee el atributo que permite deslizar dentro de la estructura en caso de que haya sobrepasado el tama√±o apropiado para el contenido. El bot√≥n lleva a la vista respectiva de estudiantes, y se muestran los estudiantes. Se a√±aden los ifs para no generar un bot√≥n inutil en caso de que no hayan estudiantes. La box final (que ocupa el espacio de dos boxes en el grid, y que representa los pre-requisitos, tambi√©n tiene el atributo de deslizamiento y el bot√≥n correspondiente).


<h4> Lo que respecta a course_prequesites </h4>

En lo que respecta a course_prerequisites, se crea de la siguiente forma. Esto es siguiendo la estructura que defini√≥ Chiara m√°s abajo con algunas modificaciones.

from app import db

        class CoursePrerequisite(db.Model):
        __tablename__ = 'course_prerequisites'

        course_id = db.Column(db.Integer, db.ForeignKey('courses.id'), primary_key=True)
        prerequisite_id = db.Column(db.Integer, db.ForeignKey('courses.id'), primary_key=True)

        course = db.relationship('Course', foreign_keys=[course_id], back_populates='prerequisites')
        prerequisite = db.relationship('Course', foreign_keys=[prerequisite_id], back_populates='prerequired_by')

En primer lugar, al referenciar la misma tabla, cambian algunas cosas. La referencia a foreign_key al definir las relaciones con db.relationship es necesaria (ya que apuntan a la misma tabla), si no SQL Alchemy crashea. 

Se modifica course al final pare incluir lo mismo:

    prerequisites = db.relationship('CoursePrerequisite', back_populates='course', foreign_keys='CoursePrerequisite.course_id')
    prerequired_by = db.relationship('CoursePrerequisite', back_populates='prerequisite', foreign_keys='CoursePrerequisite.prerequisite_id')


Nuevamente, la hiperesfecificidad del asunto es necesaria para que el sistema entienda bien lo que se est√° haciendo.

El procedimiento estandar que procede es crear las rutas, el controlador y a√±adir todo en la inicializaci√≥n de la app de la siguiente forma.

    from app.routes.course_prerequisite_routes import course_prerequisite_bp  
    app.register_blueprint(course_prerequisite_bp)  

Las rutas y el controlador son triviales -incluyen los m√©todos estandar de GET, POST, PUT Y DELETE. Es importante recordar de todas formas que est√°n establecidas. Se declaran las vistas para index -todos los pares-, create, delete, edit y show -supongo que es importante para ver un par espec√≠fico y hacer update, pero quiz√° pueda optimizarse para mostrar todos los prerequisitos de un ramo. Para esto, habr√≠a que filtrar en la base de datos.

El m√©todo DELETE fue dificil de hilar porque requiere pasar muchas veces la dupla de prerequisito y curso. El m√©todo para indexar todo fue m√°s f√°cil -sorprendentemente-, para el frontend solo se pasa un diccionario de la siguiente forma:

   course_prerequisites = CoursePrerequisite.query.all()

    grouped_prerequisites = {}

    for pair in course_prerequisites:
        course = pair.course
        prereq = pair.prerequisite

        if course.id not in grouped_prerequisites:
            grouped_prerequisites[course.id] = {
                "name": course.name,
                "prerequisites": []
                }

        grouped_prerequisites[course.id]["prerequisites"].append({
            "id": prereq.id,
            "name": prereq.name
        })

Esto es un JSON con estructura

        Curso{
                prerequisito1,prerequisito2...prerequisiton
        }

Es decir, solo una entrada por curso, y en cada entrada una lista con los prerequisitos. Facilita as√≠ el filtrado y permite instanciar solo un curso con TODOS sus prerequisitos respectivos. Tom√≥ sopresivamente poco hacerlo.

<h5> Avances post-revisi√≥n en clases </h5>

        def updateCoursePrerequisiteView(course_id):
        from app.models.course import Course  
        course = Course.query.get(course_id)

        if not course:
                return jsonify({'message': 'Course not found'}), 404

        if request.method == 'POST':
                ids_to_delete = request.form.getlist('prerequisite_ids')
                for prereq_id in ids_to_delete:
                pair = CoursePrerequisite.query.get((course_id, int(prereq_id)))
                if pair:
                        db.session.delete(pair)
                new_prereq_ids = request.form.getlist('new_prerequisite[]')
                for new_id in new_prereq_ids:
                if new_id and new_id != str(course_id):
                        existing = CoursePrerequisite.query.get((course_id, int(new_id)))
                        if not existing:
                        new_pair = CoursePrerequisite(course_id=course_id, prerequisite_id=int(new_id))
                        db.session.add(new_pair)

                db.session.commit()
                return redirect(url_for('course_prerequisites.updateCoursePrerequisiteView', course_id=course_id))

Se modifica la funci√≥n de update del CRUD de Course_prerequisites. Para esto, ahora recibe los par√°metros de a√±adir elementos en forma de una lista -en vez de una sola entrada- lo que permite editar un curso y a√±adirle m√°s de un curso como prerequisito sin generar conflictos en la base de datos.


## Cambios por Chiara Romanini

### Models
Los modelos es donde se definen los atributos de las tablas. El nombre de la tabla se define en plural de la siguiente manera:
```
__tablename__='evaluations'
```

Una llave for√°nea se define de la siguiente manera:
```
course_section_id = db.Column(db.Integer, db.ForeignKey('course_sections.id'), nullable=False)
```
En este ejemplo, se est√° definiendo que course_section_id es una llave for√°nea que apunta a la entidad 'CourseSection', donde su valor es el id de esta tabla.

#### Relaciones 
Las tablas desarrolladas tienen dos tipos de relaciones: las tablas que se unen a trav√©s de una llave for√°nea, y las tablas que act√∫an como una tabla intermedia para una relaci√≥n de muchos a muchos.

En el primer caso, donde la relaci√≥n entre las entidades es de uno a muchos, la relaci√≥n se tiene que definir en el modelo donde la relaci√≥n es "uno". Por ejemplo:
- Course y CourseSection tienen una relaci√≥n uno a muchos, donde Course puede tener muchos CourseSections, pero CourseSection solo pertenece a un Course. En este caso, la relaci√≥n se tiene que definir en el modelo de Course (la entidad que representa la relaci√≥n de "uno"). La relaci√≥n entre ambas entidades se define de la siguiente manera:

```
# En archivo models/course.py

sections = db.relationship('CourseSection', backref='course', lazy=True)
```

Gracias al atributo "backref", no es necesario definir la relaci√≥n en la otra entidad CourseSection. Con esto, la relaci√≥n queda establecida y se pueden realizar consultas de la siguiente naturaleza:

```
course = Course.get(1)

for section in course.sections:
        print(section.nrc)

# course.sections en este caso es una lista con todos las secciones que pertenecen al curso definido
```

Gracias al atributo "backref", tambien se pueden hacer este tipo de consultas:
```
course_section = CourseSection.get(1)

course_section.course.name # Esto muestra el nombre del curso 
```

El segundo caso es el de las tablas intermedias que representan las relaciones muchos a muchos, como lo es el caso de StudentCourses. Esta tabla se encarga de relacionar las entidades Student y CourseSection. Para esto, en el modelo de StudentCourses se tiene que establecer la relaci√≥n con estas dos entidades, de la siguiente manera:

```
# En models/student_course.py

student = db.relationship('Student', back_populates='student_courses')
course_section = db.relationship('CourseSection', back_populates='student_courses')
```

Luego en el archivo de estas entidades (student.py y course_section.py) se tiene que establecer la misma relaci√≥n pero hacia la tabla StudentCourses.
```
# En models/student.py

student_courses = db.relationship('StudentCourses', back_populates='student')
```

Lo mismo para CourseSection
```
# En models/course_section.py

student_courses = db.relationship('StudentCourses', back_populates='course_section')
```

Con esto, las consultas para obtener a los estudiantes de una secci√≥n ser√≠a de la siguiente manera:
```
section = CourseSection.get(1)
students = section.student_courses.students
```

Para simplificar esta consulta, se escribi√≥ una propiedad en cada una de las entidades con esta estructura:
```
# En models/course_section.py

@property
    def students(self):
        return [sc.student for sc in self.student_courses]
```

Con esto, las consultas se pueden realizar de la siguiente manera:
```
section = CourseSection.get(1)
students = section.students
```

Esto mismo se realiz√≥ para los estudiantes, y se puede ver en el archivo models/students.py


### Controllers
En los archivos de los controladores se encuentra el CRUD (CRU t√©cnicamente porque falta Delete) de las entidades Course, CourseSection, Evaluation, EvaluationType, Student, Teacher y StudentCourse. 

Estos controladores son los encargados de las funciones principales.

### Routes
En las rutas es donde se definen las rutas xd. Para estos archivos, intent√© que de la l√≥gica se encargaran las funciones definidas en los controladores. Por ejemplo, el GET tiene esta estructura:

```
# En el archivo routes/course_routes.py

@course_bp.route('/', methods=['GET'])
def getCoursesView():
    courses = getAllCourses()
    return render_template('courses/index.html', courses=courses)
```

Como se puede ver, en vez de realizar la consulta en esta misma funci√≥n, se llama a la funci√≥n getAllCourses() que se encuentra definida en el controlador. Si bien puede que para esta vista no afecte realizar la consulta ahi mismo, creo que en el futuro cuando tengamos que realizar m√°s l√≥gica y validaciones se puede empezar a desordenar el c√≥digo, es por esto que encuentro mejor dejar toda la l√≥gica para los controladores, y las rutas solo se encargan de llamar a estas funciones. 

### app/__init__.py
En este archivo, se tiene que agregar las rutas (blueprint) de los modelos nuevos que se creen. Por ejemplo, para Evaluation: 

```
# En archivo app/__init__.py

from app.routes.evaluation_routes import evaluation_bp
app.register_blueprint(evaluation_bp)
```

## Flujo pensado para la aplicaci√≥n
Por ahora, si bien no hay un flujo bien definido, fu√≠ desarrollando las entidades para que se vea de la siguiente manera:
1. "P√°gina principal" son los cursos (localhost/courses)
2. Desde esta vista se puede ingresar a un curso en espec√≠fico.
3. En la vista de Curso, se pueden ver sus secciones (CourseSection)
4. Al ingresar a una secci√≥n, se puede ver los estudiantes que pertenecen a esa secci√≥n, los tipos de evaluaci√≥n de esa secci√≥n (EvaluationType) y las evaluaciones de la secci√≥n (Evaluation).


Para el CRUD de los estudiantes y profesores, por ahora se tiene que manualmente ingresar la rutas respectivas de estas entidades (/students y /teachers).